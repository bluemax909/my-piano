<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
<title>×—×™×“×•×Ÿ ×ª×•×•×™× - ××©×—×§×•×Ÿ ×©×œ 50 + ×“×©×‘×•×¨×“</title>
<style>
  :root{ --card:#fff; --ink:#333; --accent:#004aad; --bg:#f0f8ff }
  *{ box-sizing:border-box }
  body {
    font-family: 'Comic Sans MS', 'Arial', sans-serif;
    background-color: var(--bg);
    direction: rtl;
    display: flex;
    gap: 12px;
    flex-direction: column; /* stack so no horizontal scroll */
    justify-content: flex-start;
    align-items: center;
    margin: 12px;
    color: var(--ink);
  }
  .quiz { text-align: center; flex: 1; width: 100%; max-width: 620px; }
  .btn-row{ display:flex; justify-content:center; gap:12px; flex-wrap:wrap }
  .stats {
    width: 100%; max-width: 620px; background: var(--card); border: 2px solid var(--ink); border-radius: 12px;
    padding: 10px; font-size: 15px; position: static; margin-top: 6px;
  }
  canvas { border: 2px solid var(--ink); background-color: white; margin: 8px auto; display: block; width: 100%; max-width: 340px; height: auto; }
  input[type=text]{ padding: 12px; font-size: 18px; margin-top: 6px; width: min(90%, 360px); }
  button{ padding: 12px 18px; font-size: 16px; margin: 8px; cursor: pointer; border-radius: 10px; border: 1px solid var(--ink); background:#fff }
  #feedback{ font-weight: bold; margin-top: 8px; min-height: 24px; }
  .correct{ color: green; } .wrong{ color: red; } .hidden{ display:none }

  /* Dashboard */
  .dashboard{ max-width: 980px; margin: 0 auto; background: var(--card); border: 3px solid var(--accent); border-radius: 16px; padding: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.2) }
  .dashboard h1{ font-size: 2rem; color: var(--accent); text-shadow: 2px 2px 3px #aad4ff; text-align: center; margin-bottom: 6px }
  .dashboard h2{ text-align:center; color: var(--ink) }
  table{ width:100%; border-collapse: collapse; margin-top: 10px }
  th, td{ border:1px solid #ddd; padding:8px; text-align:center }
  th{ background:#f0f0f0 }
  .muted{ color:#666; font-size:14px; text-align:center }

  /* ===== Mobile layout ===== */
  @media (max-width: 768px){
    body{ margin: 10px }
    h2{ font-size: 1.2rem }
    .stats{ width:100% }
    button{ width: calc(50% - 12px) }
    input[type=text]{ width:100% }
    .dashboard{ padding:12px }
    .dashboard h1{ font-size:1.6rem }
  }
</style>
</head>
<body>
  <!-- QUIZ AREA -->
  <div id="quizArea" class="quiz">
    <h2>ğŸµ ×—×™×“×•×Ÿ ×–×™×”×•×™ ×ª×•×•×™× ×‘××¤×ª×— ×¡×•×œ ğŸµ</h2>
    <div class="btn-row">
      <button id="toDashboardBtn">×œ×“×©×‘×•×¨×“ ×”××©×—×§×•× ×™×</button>
      <button id="fullscreenBtn">××¡×š ××œ×</button>
      <button id="zoomBtn">×–×•×</button>
    </div>
    <canvas id="staffCanvas" aria-label="×—××©×” ×‘××¤×ª×— ×¡×•×œ"></canvas>
    <p class="muted" style="margin:4px 0 2px">××” ×©× ×”×ª×• ×©××•×¤×™×¢?</p>
    <form id="answerForm" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" style="display:inline-block; width:100%; max-width:560px;">
      <input type="text" id="answerInput" placeholder="×”×§×œ×“ ×›××Ÿ ××ª ×©× ×”×ª×•..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="latin" />
    </form>
    <div class="btn-row">
      <button id="checkBtn">×‘×“×•×§ ×ª×©×•×‘×”</button>
      <button id="nextBtn">×”×‘×</button>
    </div>
    <div style="margin-top:6px;">
      <label for="difficultySelect" class="muted">×¨××ª ×§×•×©×™:</label>
      <select id="difficultySelect">
        <option value="staff">×‘×ª×•×š ×”×—××©×”</option>
        <option value="plus2">×—××©×” + 2 ×§×•×•×™ ×¢×–×¨</option>
        <option value="plus4">×—××©×” + 4 ×§×•×•×™ ×¢×–×¨</option>
      </select>
    </div>
    <div id="feedback"></div>
  </div>

  <!-- STATS PANEL -->
  <div class="stats" id="statsPanel">
    <h3>×¡×˜×˜×™×¡×˜×™×§×” â€” ××©×—×§×•×Ÿ × ×•×›×—×™</h3>
    <p class="muted">×™×© ×¨×§ ××©×—×§×•×Ÿ ×¤×¢×™×œ ××—×“ ×‘×›×œ ×¨×’×¢.</p>
    <p>×©××œ×” <span id="questionCount">1</span> ××ª×•×š 50</p>
    <p class="correct">× ×›×•× ×•×ª: <span id="correctCount">0</span></p>
    <p class="wrong">×˜×¢×•×™×•×ª: <span id="wrongCount">0</span></p>
    <p>××—×•×– ×”×¦×œ×—×”: <strong id="percent">0%</strong></p>
  </div>

  <!-- DASHBOARD (all gamelets) -->
  <div id="dashboardArea" class="dashboard hidden" aria-live="polite">
    <h1>ğŸ¶ ×—×™×“×•×Ÿ ×–×™×”×•×™ ×ª×•×•×™× ×‘××¤×ª×— ×¡×•×œ ğŸ¶</h1>
    <h2>×“×©×‘×•×¨×“ ×”××©×—×§×•× ×™×</h2>
    <p class="muted">×›×œ ×©×•×¨×” ××™×™×¦×’×ª ××©×—×§×•×Ÿ ×©×œ 50 ×©××œ×•×ª ×©×”×•×©×œ×. ×”×›×•×ª×¨×ª ×”×™× ×”Ö¾Date & Time ×©×œ ×¡×™×•× ×”××©×—×§×•×Ÿ.</p>
    <table>
      <thead>
        <tr>
          <th>×©× (×ª××¨×™×š ×•×©×¢×”)</th>
          <th class="correct">× ×›×•× ×•×ª</th>
          <th class="wrong">×˜×¢×•×™×•×ª</th>
          <th>××—×•×– ×”×¦×œ×—×”</th>
        </tr>
      </thead>
      <tbody id="dashboardTableBody"></tbody>
    </table>
    <div style="text-align:right; font-size:12px; color:#777; margin-top:10px;">×’×¨×¡×” 0.2</div>
    <div style="text-align:center; margin-top: 12px;" class="btn-row">
      <button id="backToActiveBtn">×—×–×¨×” ×œ××©×—×§×•×Ÿ ×”×¤×¢×™×œ</button>
      <button id="startNewBtn">×”×ª×—×œ ××©×—×§×•×Ÿ ×—×“×©</button>
    </div>
  </div>

<script>
// ===== Environment detection & helpers =====
const isMobile = /Mobi|Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.matchMedia('(max-width: 768px)').matches;
document.documentElement.classList.toggle('mobile', isMobile);

// ===== Persistence helpers (localStorage) =====
const STORAGE_KEYS = { ACTIVE: 'noteQuiz_activeGame', HISTORY: 'noteQuiz_history', DIFFICULTY: 'noteQuiz_difficulty' };
const saveActiveGame = s => localStorage.setItem(STORAGE_KEYS.ACTIVE, JSON.stringify(s));
const loadActiveGame = () => { const r = localStorage.getItem(STORAGE_KEYS.ACTIVE); return r ? JSON.parse(r) : null };
const clearActiveGame = () => localStorage.removeItem(STORAGE_KEYS.ACTIVE);
const saveHistory = a => localStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(a));
const loadHistory = () => { const r = localStorage.getItem(STORAGE_KEYS.HISTORY); return r ? JSON.parse(r) : [] };

// ===== Canvas Reflow & Geometry =====
const canvas = document.getElementById('staffCanvas');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
let CW = 560; // logical CSS width
let CH = isMobile ? 240 : 300; // logical CSS height
let left, right, topLineY, bottomLineY, lineGap;

function sizeCanvas() {
  // set CSS size first
  canvas.style.width = '100%';
  // Ensure we always get a sane width (in some environments width can be 0 on first paint)
  const rect = canvas.getBoundingClientRect();
  const widthCandidate = rect && rect.width ? rect.width : 340;
  const cssWidth = Math.min(340, widthCandidate);
  const cssHeight = Math.round(cssWidth * 0.5);
  // set backing store size (crisp on HiDPI)
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.floor(cssWidth * DPR);
  canvas.height = Math.floor(cssHeight * DPR);
  canvas.style.height = cssHeight + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  // recompute geometry relative to size
  CW = cssWidth; CH = cssHeight;
  lineGap = Math.min(Math.max(CH * 0.10, 14), 26); // 14â€“26px depending on height
  const staffMidY = Math.round(CH * 0.5);
  topLineY = Math.round(staffMidY - 2 * lineGap);
  bottomLineY = Math.round(topLineY + 4 * lineGap);
  left = Math.round(CW * 0.12); right = Math.round(CW * 0.88);
}

// Build full note map based on current geometry
function getFullNoteMap(){
  return [
    // BELOW staff down to 4 ledger lines
    { name: '×¨×”', y: bottomLineY + 10 },
    { name: '×“×•', y: bottomLineY + 20 },
    { name: '×¡×™', y: bottomLineY + 30 },
    { name: '×œ×”', y: bottomLineY + 40 },
    { name: '×¡×•×œ', y: bottomLineY + 50 },
    { name: '×¤×”', y: bottomLineY + 60 },
    { name: '××™', y: bottomLineY + 70 },
    { name: '×¨×”', y: bottomLineY + 80 },
    // WITHIN staff (E4..F5)
    { name: '××™', y: bottomLineY },
    { name: '×¤×”', y: bottomLineY - 10 },
    { name: '×¡×•×œ', y: bottomLineY - 20 },
    { name: '×œ×”', y: bottomLineY - 30 },
    { name: '×¡×™', y: bottomLineY - 40 },
    { name: '×“×•', y: bottomLineY - 50 },
    { name: '×¨×”', y: bottomLineY - 60 },
    { name: '××™', y: bottomLineY - 70 },
    { name: '×¤×”', y: bottomLineY - 80 },
    // ABOVE staff up to 4 ledger lines
    { name: '×¡×•×œ', y: topLineY - 10 },
    { name: '×œ×”', y: topLineY - 20 },
    { name: '×¡×™', y: topLineY - 30 },
    { name: '×“×•', y: topLineY - 40 },
    { name: '×¨×”', y: topLineY - 50 },
    { name: '××™', y: topLineY - 60 },
    { name: '×¤×”', y: topLineY - 70 },
    { name: '×¡×•×œ', y: topLineY - 80 }
  ];
}

// ===== Difficulty =====
const DIFFICULTY = { STAFF_ONLY:'staff', PLUS_2:'plus2', PLUS_4:'plus4' };
let difficulty = localStorage.getItem('noteQuiz_difficulty') || DIFFICULTY.PLUS_2;
function setDifficulty(newLevel){ difficulty=newLevel; localStorage.setItem('noteQuiz_difficulty', difficulty); pickAndDraw(); }
function filteredNotesByDifficulty(){
  const map = getFullNoteMap();
  let minY, maxY;
  if (difficulty===DIFFICULTY.STAFF_ONLY){ minY=topLineY; maxY=bottomLineY; }
  else if (difficulty===DIFFICULTY.PLUS_2){ minY=topLineY-40; maxY=bottomLineY+40; }
  else { minY=topLineY-80; maxY=bottomLineY+80; }
  return map.filter(n=> n.y>=minY && n.y<=maxY);
}

// ===== Game State =====
let activeGame = null; // {id, startedAt, currentQuestion, correct, wrong}
let history = loadHistory();
let currentNote; const TOTAL_QUESTIONS = 50;

// ===== UI Refs =====
const feedback = document.getElementById('feedback');
const answerInput = document.getElementById('answerInput');
const answerForm = document.getElementById('answerForm');
if (answerForm) answerForm.addEventListener('submit', (e)=> e.preventDefault());
if (answerInput){
  answerInput.setAttribute('name', 'ans_'+Date.now());
  answerInput.setAttribute('autocomplete','off');
  answerInput.setAttribute('autocorrect','off');
  answerInput.setAttribute('autocapitalize','off');
  answerInput.setAttribute('spellcheck','false');
}
const qCount = document.getElementById('questionCount');
const correctCount = document.getElementById('correctCount');
const wrongCount = document.getElementById('wrongCount');
const percentSpan = document.getElementById('percent');
const quizArea = document.getElementById('quizArea');
const statsPanel = document.getElementById('statsPanel');
const dashboardArea = document.getElementById('dashboardArea');
const dashboardTableBody = document.getElementById('dashboardTableBody');

// ===== Utilities =====
const formatDT = (iso)=>{ try{ return new Date(iso).toLocaleString('he-IL',{hour12:false}); }catch(e){ return iso } };
const calcPercent = (c,w)=>{ const t=c+w; return t? Math.round((c/t)*100):0 };

// ===== Drawing =====
function drawStaff(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 1.5;
  for (let i=0;i<5;i++){
    const y = topLineY + i*lineGap;
    ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke();
  }
  ctx.font = Math.round(lineGap*2) + 'px serif';
  ctx.fillText('ğ„', left - lineGap*0.8, topLineY + lineGap*2.7);
}
function drawLedgerLines(y){
  const cx=(left+right)/2, half=Math.max(18, lineGap*1.1);
  for (let ly=topLineY-20; ly>=y; ly-=20){ if (ly<topLineY && Math.abs(ly-y)<=10){ ctx.beginPath(); ctx.moveTo(cx-half,ly); ctx.lineTo(cx+half,ly); ctx.stroke(); } }
  for (let ly=bottomLineY+20; ly<=y; ly+=20){ if (ly>bottomLineY && Math.abs(ly-y)<=10){ ctx.beginPath(); ctx.moveTo(cx-half,ly); ctx.lineTo(cx+half,ly); ctx.stroke(); } }
}
function drawNote(note){
  drawStaff();
  if (note.y < topLineY || note.y > bottomLineY) drawLedgerLines(note.y);
  const cx=(left+right)/2;
  ctx.beginPath(); ctx.ellipse(cx, note.y, lineGap*0.6, lineGap*0.45, -0.35, 0, Math.PI*2); ctx.fillStyle='#000'; ctx.fill();
  const mid = topLineY + 2*lineGap;
  if (note.y > mid){ ctx.beginPath(); ctx.moveTo(cx+lineGap*0.5, note.y); ctx.lineTo(cx+lineGap*0.5, note.y - lineGap*1.8); ctx.stroke(); }
  else { ctx.beginPath(); ctx.moveTo(cx-lineGap*0.5, note.y); ctx.lineTo(cx-lineGap*0.5, note.y + lineGap*1.8); ctx.stroke(); }
}

function randomNote(){ const pool = filteredNotesByDifficulty(); return pool[Math.floor(Math.random()*pool.length)] }
function pickAndDraw(){ currentNote = randomNote(); drawNote(currentNote); if(activeGame){ qCount.textContent=activeGame.currentQuestion; correctCount.textContent=activeGame.correct; wrongCount.textContent=activeGame.wrong; percentSpan.textContent=calcPercent(activeGame.correct, activeGame.wrong)+'%'; } feedback.textContent=''; answerInput.value=''; answerInput.focus(); }

// ===== Answer Handling =====
function normalizeAnswer(str){ const s=(str||'').trim().toLowerCase(); const map={ '×“×•':'×“×•','do':'×“×•','×¨×”':'×¨×”','re':'×¨×”','××™':'××™','mi':'××™','×¤×”':'×¤×”','fa':'×¤×”','×¡×•×œ':'×¡×•×œ','sol':'×¡×•×œ','×œ×”':'×œ×”','la':'×œ×”','×¡×™':'×¡×™','si':'×¡×™','ti':'×¡×™' }; return map[s]||s }
function recordAndAdvance(ok){
  if(!activeGame) return;
  // Haptics
  if (navigator.vibrate) { navigator.vibrate(ok ? 30 : [20,50,20]); }
  // Visual feedback (1.5s)
  if(ok){
    activeGame.correct++;
    feedback.textContent='× ×›×•×Ÿ ×××•×“! ğŸ‰';
    feedback.style.color='green';
    feedback.classList.add('correct');
    feedback.classList.remove('wrong');
  } else {
    activeGame.wrong++;
    feedback.textContent=`×œ× × ×›×•×Ÿ. ×”×ª×©×•×‘×” ×”×™× ${currentNote.name}.`;
    feedback.style.color='red';
    feedback.classList.add('wrong');
    feedback.classList.remove('correct');
  }
  if(activeGame.currentQuestion < 50){
    activeGame.currentQuestion++;
    saveActiveGame(activeGame);
    correctCount.textContent=activeGame.correct;
    wrongCount.textContent=activeGame.wrong;
    percentSpan.textContent=calcPercent(activeGame.correct, activeGame.wrong)+'%';
    setTimeout(pickAndDraw, 1500);
  } else {
    const finishedAt=new Date().toISOString();
    const percent=calcPercent(activeGame.correct, activeGame.wrong);
    const title=formatDT(finishedAt);
    const historyArr=history||[];
    historyArr.push({id:activeGame.id, finishedAt, correct:activeGame.correct, wrong:activeGame.wrong, percent, title});
    history=historyArr;
    saveHistory(history);
    clearActiveGame();
    activeGame=null;
    renderDashboard();
    showDashboard();
  }
}
function checkCurrentAnswer(){ const ans=normalizeAnswer(answerInput.value); if(!ans){ feedback.textContent='×× × ×›×ª×•×‘ ×ª×©×•×‘×”.'; feedback.style.color='black'; return null } return ans===currentNote.name }

// ===== Dashboard =====
function renderDashboard(){ dashboardTableBody.innerHTML=''; if(!history.length){ const tr=document.createElement('tr'); tr.innerHTML = `<td colspan="4" class="muted">××™×Ÿ ×¢×“×™×™×Ÿ ××©×—×§×•× ×™× ×©×”×•×©×œ××•</td>`; dashboardTableBody.appendChild(tr); return } const rows=[...history].sort((a,b)=> new Date(b.finishedAt)-new Date(a.finishedAt)); rows.forEach(g=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${g.title}</td><td class="correct">${g.correct}</td><td class="wrong">${g.wrong}</td><td>${g.percent}%</td>`; dashboardTableBody.appendChild(tr) }) }
function showDashboard(){ quizArea.classList.add('hidden'); statsPanel.classList.add('hidden'); dashboardArea.classList.remove('hidden') }
function showQuiz(){ dashboardArea.classList.add('hidden'); quizArea.classList.remove('hidden'); statsPanel.classList.remove('hidden'); pickAndDraw() }

// ===== Start / Resume game =====
function startNewGame(){ if(activeGame){ alert('×›×‘×¨ ×™×© ××©×—×§×•×Ÿ ×¤×¢×™×œ. ×¡×™×™× ××•×ª×• ××• ×¢×‘×•×¨ ×œ×“×©×‘×•×¨×“.'); return } activeGame={ id:'game_'+Date.now(), startedAt:new Date().toISOString(), currentQuestion:1, correct:0, wrong:0 }; saveActiveGame(activeGame); showQuiz() }
function resumeActiveIfAny(){ const stored=loadActiveGame(); if(stored && (stored.currentQuestion<=50)){ activeGame=stored; showQuiz() } else { startNewGame() } }

// ===== Listeners =====
document.getElementById('checkBtn').addEventListener('click', ()=>{ const r=checkCurrentAnswer(); if(r===null) return; recordAndAdvance(r) });
document.getElementById('nextBtn').addEventListener('click', ()=>{ const r=checkCurrentAnswer(); if(r===null) return; recordAndAdvance(r) });
answerInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ const r=checkCurrentAnswer(); if(r===null) return; recordAndAdvance(r) } });

const toDashboardBtn=document.getElementById('toDashboardBtn'); if(toDashboardBtn) toDashboardBtn.addEventListener('click', ()=>{ renderDashboard(); showDashboard() });
const backToActiveBtn=document.getElementById('backToActiveBtn'); if(backToActiveBtn) backToActiveBtn.addEventListener('click', ()=>{ const stored=loadActiveGame(); if(stored){ activeGame=stored; showQuiz() } else { startNewGame() } });
const startNewBtn=document.getElementById('startNewBtn'); if(startNewBtn) startNewBtn.addEventListener('click', startNewGame);

const difficultySelect=document.getElementById('difficultySelect'); if(difficultySelect){ difficultySelect.value=difficulty; difficultySelect.addEventListener('change', e=> setDifficulty(e.target.value)) }

// Fullscreen support (mobile-first with fallback)
const fsBtn = document.getElementById('fullscreenBtn');
function enterPseudoFullscreen(){ document.body.style.position='fixed'; document.body.style.inset='0'; document.body.style.overflow='hidden'; window.scrollTo(0,0); sizeCanvas(); pickAndDraw(); }
function exitPseudoFullscreen(){ document.body.style.position=''; document.body.style.inset=''; document.body.style.overflow=''; sizeCanvas(); pickAndDraw(); }
async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement){
      if(document.documentElement.requestFullscreen){ await document.documentElement.requestFullscreen(); }
      else { enterPseudoFullscreen(); }
    } else {
      if(document.exitFullscreen){ await document.exitFullscreen(); }
      else { exitPseudoFullscreen(); }
    }
  }catch(e){ if(document.body.style.position==='fixed') exitPseudoFullscreen(); else enterPseudoFullscreen(); }
}
if (fsBtn) fsBtn.addEventListener('click', toggleFullscreen);
document.addEventListener('fullscreenchange', ()=>{ sizeCanvas(); pickAndDraw(); });

// Zoom toggle
const zoomBtn = document.getElementById('zoomBtn');
let zoomed = false;
function toggleZoom(){ zoomed = !zoomed; const scale = zoomed ? 1.5 : 1; canvas.style.transform = `scale(${scale})`; canvas.style.transformOrigin = 'center'; }
if (zoomBtn) zoomBtn.addEventListener('click', toggleZoom);
canvas.addEventListener('dblclick', toggleZoom);

// ===== Simple runtime tests (console) =====
(function selfTests(){
  try {
    console.group('%cSelf tests','color: #004aad');
    sizeCanvas();
    const poolStaff = (function(){ const d=difficulty; difficulty=DIFFICULTY.STAFF_ONLY; const p=filteredNotesByDifficulty(); difficulty=d; return p; })();
    console.assert(Array.isArray(poolStaff) && poolStaff.length > 0, 'Pool (staff only) should not be empty');
    const poolPlus2 = (function(){ const d=difficulty; difficulty=DIFFICULTY.PLUS_2; const p=filteredNotesByDifficulty(); difficulty=d; return p; })();
    console.assert(poolPlus2.length >= poolStaff.length, 'Plus2 pool should be >= staff');
    const poolPlus4 = (function(){ const d=difficulty; difficulty=DIFFICULTY.PLUS_4; const p=filteredNotesByDifficulty(); difficulty=d; return p; })();
    console.assert(poolPlus4.length >= poolPlus2.length, 'Plus4 pool should be >= plus2');
    console.assert(typeof randomNote()==='object', 'randomNote returns an object');
    console.assert(typeof drawStaff === 'function' && typeof drawNote === 'function', 'draw functions exist');
    console.log('âœ… Self tests passed');
    console.groupEnd();
  } catch(err){ console.error('Self tests failed:', err); }
})();

// ===== Init =====
function init(){ sizeCanvas(); renderDashboard(); resumeActiveIfAny(); }
window.addEventListener('resize', ()=>{ const wasDash = !dashboardArea.classList.contains('hidden'); sizeCanvas(); if(!wasDash) pickAndDraw() });
init();
</script>
</body>
</html>
