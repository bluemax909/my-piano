<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>×—×™×“×•×Ÿ ×ª×•×•×™× - ××©×—×§×•×Ÿ ×©×œ 50 + ×“×©×‘×•×¨×“</title>
<style>
  body {
    font-family: 'Arial', sans-serif;
    background-color: #f8f9fa;
    direction: rtl;
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    align-items: flex-start;
    margin: 20px;
  }
  .quiz { text-align: center; flex: 1; }
  .stats {
    width: 300px; background: #fff; border: 2px solid #333; border-radius: 10px;
    padding: 15px; font-size: 16px; position: sticky; top: 20px;
  }
  canvas { border: 2px solid #333; background-color: white; margin: 20px auto; display: block; }
  input[type=text] { padding: 10px; font-size: 18px; margin-top: 10px; width: 260px; }
  button { padding: 10px 20px; font-size: 16px; margin: 10px; cursor: pointer; }
  #feedback { font-weight: bold; margin-top: 10px; min-height: 24px; }
  .correct { color: green; }
  .wrong { color: red; }
  .hidden { display: none; }

  /* Dashboard */
  .dashboard {
    max-width: 980px; margin: 0 auto; background: #fff; border: 2px solid #333; border-radius: 12px; padding: 16px;
  }
  table { width: 100%; border-collapse: collapse; margin-top: 10px; }
  th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
  th { background: #f0f0f0; }
  .muted { color: #666; font-size: 14px; }
</style>
</head>
<body>
  <!-- QUIZ AREA -->
  <div id="quizArea" class="quiz">
    <h2>ğŸµ ×—×™×“×•×Ÿ ×–×™×”×•×™ ×ª×•×•×™× ×‘××¤×ª×— ×¡×•×œ ğŸµ</h2>
    <div>
      <button id="toDashboardBtn">×œ×“×©×‘×•×¨×“ ×”××©×—×§×•× ×™×</button>
    </div>
    <canvas id="staffCanvas" width="520" height="280"></canvas>
    <p>××” ×©× ×”×ª×• ×©××•×¤×™×¢?</p>
    <input type="text" id="answerInput" placeholder="×”×§×œ×“ ×›××Ÿ ××ª ×©× ×”×ª×•..." />
    <div>
      <!-- "×”×‘×" ×‘×•×“×§ ×•×’× ××ª×§×“× -->
      <button id="checkBtn">×‘×“×•×§ ×ª×©×•×‘×”</button>
      <button id="nextBtn">×”×‘×</button>
    </div>
    <div style="margin-top:6px;">
      <label for="difficultySelect" class="muted">×¨××ª ×§×•×©×™:</label>
      <select id="difficultySelect">
        <option value="staff">×‘×ª×•×š ×”×—××©×”</option>
        <option value="plus2">×—××©×” + 2 ×§×•×•×™ ×¢×–×¨</option>
        <option value="plus4">×—××©×” + 4 ×§×•×•×™ ×¢×–×¨</option>
      </select>
    </div>
    <div id="feedback"></div>
  </div>

  <!-- STATS PANEL -->
  <div class="stats" id="statsPanel">
    <h3>×¡×˜×˜×™×¡×˜×™×§×” â€” ××©×—×§×•×Ÿ × ×•×›×—×™</h3>
    <p class="muted">×™×© ×¨×§ ××©×—×§×•×Ÿ ×¤×¢×™×œ ××—×“ ×‘×›×œ ×¨×’×¢.</p>
    <p>×©××œ×” <span id="questionCount">1</span> ××ª×•×š 50</p>
    <p class="correct">× ×›×•× ×•×ª: <span id="correctCount">0</span></p>
    <p class="wrong">×˜×¢×•×™×•×ª: <span id="wrongCount">0</span></p>
    <p>××—×•×– ×”×¦×œ×—×”: <strong id="percent">0%</strong></p>
  </div>

  <!-- DASHBOARD (all gamelets) -->
  <div id="dashboardArea" class="dashboard hidden">
    <h2>×“×©×‘×•×¨×“ ××©×—×§×•× ×™×</h2>
    <p class="muted">×›×œ ×©×•×¨×” ××™×™×¦×’×ª ××©×—×§×•×Ÿ ×©×œ 50 ×©××œ×•×ª ×©×”×•×©×œ×. ×”×›×•×ª×¨×ª ×”×™× ×”Ö¾Date & Time ×©×œ ×¡×™×•× ×”××©×—×§×•×Ÿ.</p>
    <table>
      <thead>
        <tr>
          <th>×©× (×ª××¨×™×š ×•×©×¢×”)</th>
          <th class="correct">× ×›×•× ×•×ª</th>
          <th class="wrong">×˜×¢×•×™×•×ª</th>
          <th>××—×•×– ×”×¦×œ×—×”</th>
        </tr>
      </thead>
      <tbody id="dashboardTableBody"></tbody>
    </table>
    <div style="text-align:center; margin-top: 12px;">
      <button id="backToActiveBtn">×—×–×¨×” ×œ××©×—×§×•×Ÿ ×”×¤×¢×™×œ</button>
      <button id="startNewBtn">×”×ª×—×œ ××©×—×§×•×Ÿ ×—×“×©</button>
    </div>
  </div>

  <script>
    // ===== Persistence helpers (localStorage) =====
    const STORAGE_KEYS = {
      ACTIVE: 'noteQuiz_activeGame',
      HISTORY: 'noteQuiz_history'
    };

    function saveActiveGame(state) {
      localStorage.setItem(STORAGE_KEYS.ACTIVE, JSON.stringify(state));
    }
    function loadActiveGame() {
      const raw = localStorage.getItem(STORAGE_KEYS.ACTIVE);
      return raw ? JSON.parse(raw) : null;
    }
    function clearActiveGame() { localStorage.removeItem(STORAGE_KEYS.ACTIVE); }

    function saveHistory(arr) { localStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(arr)); }
    function loadHistory() {
      const raw = localStorage.getItem(STORAGE_KEYS.HISTORY);
      return raw ? JSON.parse(raw) : [];
    }

    // ===== Canvas + Staff Geometry =====
    const canvas = document.getElementById('staffCanvas');
    const ctx = canvas.getContext('2d');
    const left = 50, right = 450;
    const topLineY = 80;      // line 5 (top) â€” shifted for more headroom      // line 5 (top)
    const lineGap = 20;       // distance between staff lines
    const bottomLineY = topLineY + 4 * lineGap; // line 1 (bottom) = 140

    // Notes on treble clef â€” extended 4 up / 4 down with correct Hebrew names
    // Inside staff: E4..F5 | Above: G5 A5 B5 C6 | Below: D4 C4 B3 A3
    const fullNoteMap = [
      // ==== BELOW STAFF (down to D3 for Â±4) ====
      { name: '×¨×”', y: (topLineY + 4*lineGap) + 10 },  // D4 (space below staff)
      { name: '×“×•', y: (topLineY + 4*lineGap) + 20 },  // C4 (ledger 1)
      { name: '×¡×™', y: (topLineY + 4*lineGap) + 30 },  // B3 (space)
      { name: '×œ×”', y: (topLineY + 4*lineGap) + 40 },  // A3 (ledger 2)
      { name: '×¡×•×œ', y: (topLineY + 4*lineGap) + 50 }, // G3 (space)
      { name: '×¤×”', y: (topLineY + 4*lineGap) + 60 },  // F3 (ledger 3)
      { name: '××™', y: (topLineY + 4*lineGap) + 70 },  // E3 (space)
      { name: '×¨×”', y: (topLineY + 4*lineGap) + 80 },  // D3 (ledger 4)

      // ==== WITHIN STAFF (E4..F5) ====
      { name: '××™', y: (topLineY + 4*lineGap) },       // E4 line 1
      { name: '×¤×”', y: (topLineY + 4*lineGap) - 10 },  // F4 space 1
      { name: '×¡×•×œ', y: (topLineY + 4*lineGap) - 20 }, // G4 line 2
      { name: '×œ×”', y: (topLineY + 4*lineGap) - 30 },  // A4 space 2
      { name: '×¡×™', y: (topLineY + 4*lineGap) - 40 },  // B4 line 3
      { name: '×“×•', y: (topLineY + 4*lineGap) - 50 },  // C5 space 3
      { name: '×¨×”', y: (topLineY + 4*lineGap) - 60 },  // D5 line 4
      { name: '××™', y: (topLineY + 4*lineGap) - 70 },  // E5 space 4
      { name: '×¤×”', y: (topLineY + 4*lineGap) - 80 },  // F5 line 5

      // ==== ABOVE STAFF (up to G6 for Â±4) ====
      { name: '×¡×•×œ', y: topLineY - 10 },    // G5 (space)
      { name: '×œ×”', y: topLineY - 20 },     // A5 (ledger 1)
      { name: '×¡×™', y: topLineY - 30 },     // B5 (space)
      { name: '×“×•', y: topLineY - 40 },     // C6 (ledger 2)
      { name: '×¨×”', y: topLineY - 50 },     // D6 (space)
      { name: '××™', y: topLineY - 60 },     // E6 (ledger 3)
      { name: '×¤×”', y: topLineY - 70 },     // F6 (space)
      { name: '×¡×•×œ', y: topLineY - 80 }     // G6 (ledger 4)
    ];

    // ===== Difficulty =====
    const DIFFICULTY = {
      STAFF_ONLY: 'staff',       // ×‘×ª×•×š ×”×—××©×”
      PLUS_2: 'plus2',           // ×—××©×” + 2 ×§×•×•×™ ×¢×–×¨
      PLUS_4: 'plus4'            // ×—××©×” + 4 ×§×•×•×™ ×¢×–×¨
    };
    let difficulty = localStorage.getItem('noteQuiz_difficulty') || DIFFICULTY.PLUS_2;

    function setDifficulty(newLevel) {
      difficulty = newLevel;
      localStorage.setItem('noteQuiz_difficulty', difficulty);
      // Refresh current pool and redraw
      pickAndDraw();
    }

    function filteredNotesByDifficulty() {
      const bottomLineY = topLineY + 4*lineGap;
      let minY, maxY;
      if (difficulty === DIFFICULTY.STAFF_ONLY) {
        minY = topLineY;               // top line
        maxY = bottomLineY;            // bottom line
      } else if (difficulty === DIFFICULTY.PLUS_2) {
        minY = topLineY - 40;          // up to ledger 2 above
        maxY = bottomLineY + 40;       // down to ledger 2 below
      } else { // PLUS_4
        minY = topLineY - 80;          // up to ledger 4 above
        maxY = bottomLineY + 80;       // down to ledger 4 below
      }
      return fullNoteMap.filter(n => n.y >= minY && n.y <= maxY);
    }

    // ===== Game State =====
    let activeGame = null; // {id, startedAt, currentQuestion, correct, wrong}
    let history = loadHistory(); // [{id, finishedAt, correct, wrong, percent, title}]
    let currentNote;
    const TOTAL_QUESTIONS = 50;

    // ===== UI Refs =====
    const feedback = document.getElementById('feedback');
    const answerInput = document.getElementById('answerInput');
    const qCount = document.getElementById('questionCount');
    const correctCount = document.getElementById('correctCount');
    const wrongCount = document.getElementById('wrongCount');
    const percentSpan = document.getElementById('percent');
    const quizArea = document.getElementById('quizArea');
    const statsPanel = document.getElementById('statsPanel');
    const dashboardArea = document.getElementById('dashboardArea');
    const dashboardTableBody = document.getElementById('dashboardTableBody');

    // ===== Utilities =====
    function formatDT(iso) {
      try { return new Date(iso).toLocaleString('he-IL', { hour12: false }); }
      catch(e){ return iso; }
    }
    function calcPercent(c, w) {
      const total = c + w; return total === 0 ? 0 : Math.round((c / total) * 100);
    }

    // ===== Drawing =====
    function drawStaff() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 5; i++) {
        const y = topLineY + i * lineGap;
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(right, y);
        ctx.stroke();
      }
      // Treble clef
      ctx.font = '40px serif';
      ctx.fillText('ğ„', left + 5, topLineY + 55);
    }

    function drawLedgerLines(y) {
      // Draw short ledger lines for notes above/below the staff where needed (only on line positions)
      const half = 22; // half length of small ledger line
      // Above staff: line positions every 20px starting from topLineY - 20, -40, ...
      for (let ly = topLineY - 20; ly >= y; ly -= 20) {
        if (Math.abs(ly - y) <= 10 || ly < topLineY) {
          ctx.beginPath();
          ctx.moveTo((left + right)/2 - half, ly);
          ctx.lineTo((left + right)/2 + half, ly);
          ctx.stroke();
        }
      }
      // Below staff: line positions every 20px starting from bottomLineY + 20, +40, ...
      for (let ly = bottomLineY + 20; ly <= y; ly += 20) {
        if (Math.abs(ly - y) <= 10 || ly > bottomLineY) {
          ctx.beginPath();
          ctx.moveTo((left + right)/2 - half, ly);
          ctx.lineTo((left + right)/2 + half, ly);
          ctx.stroke();
        }
      }
    }

    function drawNote(note) {
      drawStaff();
      // Ledger lines first if needed
      if (note.y < topLineY || note.y > bottomLineY) {
        drawLedgerLines(note.y);
      }
      // Notehead
      ctx.beginPath();
      ctx.ellipse((left + right) / 2, note.y, 12, 8, -0.35, 0, Math.PI * 2);
      ctx.fillStyle = 'black';
      ctx.fill();
      // Stem (direction based on middle line (y=100))
      const middleLineY = topLineY + 2 * lineGap;
      if (note.y > middleLineY) {
        // stem up
        ctx.beginPath();
        ctx.moveTo((left + right) / 2 + 10, note.y);
        ctx.lineTo((left + right) / 2 + 10, note.y - 35);
        ctx.stroke();
      } else {
        // stem down
        ctx.beginPath();
        ctx.moveTo((left + right) / 2 - 10, note.y);
        ctx.lineTo((left + right) / 2 - 10, note.y + 35);
        ctx.stroke();
      }
    }

    function randomNote() { 
      const pool = filteredNotesByDifficulty();
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function pickAndDraw() {
      currentNote = randomNote();
      drawNote(currentNote);
      qCount.textContent = activeGame.currentQuestion;
      correctCount.textContent = activeGame.correct;
      wrongCount.textContent = activeGame.wrong;
      percentSpan.textContent = calcPercent(activeGame.correct, activeGame.wrong) + '%';
      answerInput.value = '';
      feedback.textContent = '';
      answerInput.focus();
    }

    // ===== Answer Handling =====
    function normalizeAnswer(str) {
      const s = (str || '').trim().toLowerCase();
      const map = {
        '×“×•': '×“×•', 'do': '×“×•',
        '×¨×”': '×¨×”', 're': '×¨×”',
        '××™': '××™', 'mi': '××™',
        '×¤×”': '×¤×”', 'fa': '×¤×”',
        '×¡×•×œ': '×¡×•×œ', 'sol': '×¡×•×œ',
        '×œ×”': '×œ×”', 'la': '×œ×”',
        '×¡×™': '×¡×™', 'si': '×¡×™', 'ti': '×¡×™'
      };
      return map[s] || s;
    }

    function recordAndAdvance(isCorrect) {
      if (isCorrect) {
        activeGame.correct++; feedback.textContent = '× ×›×•×Ÿ ×××•×“! ğŸ‰'; feedback.style.color = 'green';
      } else {
        activeGame.wrong++; feedback.textContent = `×œ× × ×›×•×Ÿ. ×”×ª×©×•×‘×” ×”×™× ${currentNote.name}.`; feedback.style.color = 'red';
      }

      // advance question counter or finish
      if (activeGame.currentQuestion < TOTAL_QUESTIONS) {
        activeGame.currentQuestion++;
        saveActiveGame(activeGame);
        // update side stats & move on
        correctCount.textContent = activeGame.correct;
        wrongCount.textContent = activeGame.wrong;
        percentSpan.textContent = calcPercent(activeGame.correct, activeGame.wrong) + '%';
        setTimeout(pickAndDraw, 300);
      } else {
        // Finish gamelet
        const finishedAt = new Date().toISOString();
        const percent = calcPercent(activeGame.correct, activeGame.wrong);
        const title = formatDT(finishedAt);
        history.push({ id: activeGame.id, finishedAt, correct: activeGame.correct, wrong: activeGame.wrong, percent, title });
        saveHistory(history);
        clearActiveGame();
        activeGame = null;
        renderDashboard();
        showDashboard();
      }
    }

    function checkCurrentAnswer() {
      const userAnswer = normalizeAnswer(answerInput.value);
      if (!userAnswer) { feedback.textContent = '×× × ×›×ª×•×‘ ×ª×©×•×‘×”.'; feedback.style.color = 'black'; return null; }
      return userAnswer === currentNote.name; // true/false
    }

    // ===== Dashboard =====
    function renderDashboard() {
      dashboardTableBody.innerHTML = '';
      if (!history.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="4" class="muted">××™×Ÿ ×¢×“×™×™×Ÿ ××©×—×§×•× ×™× ×©×”×•×©×œ××•</td>`;
        dashboardTableBody.appendChild(tr);
        return;
      }
      // newest first
      const rows = [...history].sort((a,b) => new Date(b.finishedAt) - new Date(a.finishedAt));
      rows.forEach(g => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${g.title}</td>
          <td class="correct">${g.correct}</td>
          <td class="wrong">${g.wrong}</td>
          <td>${g.percent}%</td>
        `;
        dashboardTableBody.appendChild(tr);
      });
    }

    function showDashboard() {
      quizArea.classList.add('hidden');
      statsPanel.classList.add('hidden');
      dashboardArea.classList.remove('hidden');
    }
    function showQuiz() {
      dashboardArea.classList.add('hidden');
      quizArea.classList.remove('hidden');
      statsPanel.classList.remove('hidden');
      if (activeGame) pickAndDraw();
    }

    // ===== Start / Resume game =====
    function startNewGame() {
      if (activeGame) { alert('×›×‘×¨ ×™×© ××©×—×§×•×Ÿ ×¤×¢×™×œ. ×¡×™×™× ××•×ª×• ××• ×¢×‘×•×¨ ×œ×“×©×‘×•×¨×“.'); return; }
      activeGame = {
        id: 'game_' + Date.now(),
        startedAt: new Date().toISOString(),
        currentQuestion: 1,
        correct: 0,
        wrong: 0
      };
      saveActiveGame(activeGame);
      showQuiz();
      pickAndDraw();
    }

    function resumeActiveIfAny() {
      const stored = loadActiveGame();
      if (stored && (stored.currentQuestion <= TOTAL_QUESTIONS)) {
        activeGame = stored;
        showQuiz();
        pickAndDraw();
      } else {
        // no active game â€” go to dashboard by default
        renderDashboard();
        showDashboard();
      }
    }

    // ===== Event Listeners =====
    document.getElementById('checkBtn').addEventListener('click', () => {
      const res = checkCurrentAnswer(); if (res === null) return; recordAndAdvance(res);
    });
    document.getElementById('nextBtn').addEventListener('click', () => {
      const res = checkCurrentAnswer(); if (res === null) return; recordAndAdvance(res);
    });
    answerInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { const res = checkCurrentAnswer(); if (res === null) return; recordAndAdvance(res); }
    });

    document.getElementById('toDashboardBtn').addEventListener('click', () => {
      renderDashboard(); showDashboard();
    });
    document.getElementById('backToActiveBtn').addEventListener('click', () => {
      const stored = loadActiveGame();
      if (stored) { activeGame = stored; showQuiz(); }
      else {
        alert('××™×Ÿ ××©×—×§×•×Ÿ ×¤×¢×™×œ ×›×¨×’×¢. ×”×ª×—×œ×ª ×—×“×©?');
      }
    });
    document.getElementById('startNewBtn').addEventListener('click', startNewGame);

    // ===== Init =====
    // Initialize difficulty select UI
    const difficultySelect = document.getElementById('difficultySelect');
    difficultySelect.value = difficulty;
    difficultySelect.addEventListener('change', (e) => setDifficulty(e.target.value));

    renderDashboard();
    resumeActiveIfAny();
  </script>
</body>
</html>
